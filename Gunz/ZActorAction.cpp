#include "stdafx.h"
#include "ZActorAction.h"

ZActorAction::~ZActorAction()
{
	delete m_pMeleeShot;
	
	int num = GetNumRangeShot();
	for (int i=0; i<num; ++i)
		delete m_vecRangeShot[i];
}

void ZActorActionMeleeShot::ProcessShot( IGame* pGame, const MUID& uidOwner, float fShotTime ) const
{
	// 디버그 레지스터 핵 방어 구문을 모두 제거했습니다 필요하면 추가

	ZObjectManager* pObjectManager = ZGetObjectManager();
	if (!pObjectManager) return;

	// 공격자 정보를 구함
	ZObject *pAttacker = pObjectManager->GetObject(uidOwner);
	if (!pAttacker) return;

	if (m_fRange == 0) return;

	float fRadius = cosf( ToRadian( m_fAngle * 0.5f));

	// 공격자의 위치와 방향에 대한 정규화
	rvector AttackerPos		= pAttacker->GetPosition();
	rvector AttackerNorPos	= AttackerPos;
	AttackerNorPos.z		= 0;

	rvector AttackerDir		= pAttacker->m_Direction;
	rvector AttackerNorDir	= AttackerDir;
	AttackerNorDir.z		= 0; 
	Normalize( AttackerNorDir);

	// 사운드 출력
	bool bPlayer = false;
	rvector Pos = pAttacker->GetPosition();
	ZApplication::GetSoundEngine()->PlaySoundElseDefault("blade_swing","blade_swing",rvector(Pos.x,Pos.y,Pos.z),bPlayer);

	// 공격이 타겟에 히트 했는지 체크한다.
	bool bHit = false;

	// 타켓에 대한 검사를 수행한다.
	for ( ZObjectManager::iterator itor = pObjectManager->begin(); itor != pObjectManager->end(); ++itor)
	{
		// 타겟에 대한 정보를 얻는다.
		ZObject* pVictim = (*itor).second;

		// 타켓이 죽은 상태면 다음 타겟으로 넘어간다.
		ZModule_HPAP* pModule = (ZModule_HPAP*)pVictim->GetModule(ZMID_HPAP);
		if ( pVictim->IsDie())
			continue;

		// 타겟이 공격자 자신이면 다음 타겟으로 넘어간다.
		if ( pAttacker == pVictim)
			continue;

		// 공격 가능한 상대가 아니면 다음 타겟으로 넘어간다.
		//if (!CanAttack( pAttacker, pVictim))

		if (pAttacker->GetTeamID() == pVictim->GetTeamID())
			continue;

		// 타겟의 정보를 구한다.
		rvector VictimPos, VictimDir;
		if (!pVictim->GetHistory( &VictimPos, &VictimDir, fShotTime))
			continue;

		// 공격자에 대한 타켓의 위치와 방향 정규화
		rvector VictimNorPos	= VictimPos;
		VictimNorPos.z			= 0;

		rvector VictimNorDir	= VictimPos - ( AttackerPos - ( AttackerNorDir * 50.f));
		VictimNorDir.z			= 0;
		Normalize( VictimNorDir);


		// 공격자와 타겟간의 x,y 평면 상의 거리를 구한 다음, 거리가 공격 가능 거리보다 멀면 다음 타겟으로 넘어간다.
		float fDist = Magnitude( AttackerNorPos - VictimNorPos);
		if ( fDist > m_fRange)
			continue;

		// 타켓이 공격 가능한 각도 밖이면 다음 타겟으로 넘어간다.
		float fDot = D3DXVec3Dot( &AttackerNorDir, &VictimNorDir);
		if ( fDot < fRadius)
			continue;

		// 타겟이 해당 공격 범위 안에서 일정 영역 높이에 있는지 확인한다.
		if (!pGame->InRanged(pAttacker, pVictim))
			continue;

		// 공격자와 타겟 사이에 벽이 막고 있으면 다음 타겟으로 넘어간다.
		int nDebugRegister = 0;
		if (pGame->IsWallBlocked( pAttacker, pVictim, nDebugRegister, true))
			continue;

		// 가드 상태이면서 가드 방향이 맞으면 가드 성공
		if ( pVictim->IsGuard() && ( DotProduct( pVictim->m_Direction, AttackerNorDir) < 0))
		{
			rvector pos = pVictim->GetPosition();
			pos.z += 120.f;

			// 가드 이펙트 표시
			ZGetEffectManager()->AddSwordDefenceEffect( pos + ( pVictim->m_Direction * 50.f), pVictim->m_Direction);
			pVictim->OnMeleeGuardSuccess();
			return;
		}

		// 노가드 상태에서 공격이 들어오면... 맞는 이펙트
		rvector pos = pVictim->GetPosition();
		pos.z += 130.f;
		pos   -= AttackerDir * 50.f;
		// 이펙트를 출력한다.
		ZGetEffectManager()->AddBloodEffect( pos, -VictimNorDir);
		ZGetEffectManager()->AddSlashEffect( pos, -VictimNorDir, 0);


		// 데미지 값을 구한다.
		float fActualDamage = m_fDamage; //CalcActualDamage( pAttacker, pVictim, (float)pItemDesc->m_nDamage.Ref());
		float fPierceRatio = m_fPierce; //pItem->GetPiercingRatio( pItemDesc->m_nWeaponType.Ref() , eq_parts_chest );
		pVictim->OnDamaged( pAttacker, pAttacker->GetPosition(), ZD_MELEE, MWT_DAGGER, fActualDamage, fPierceRatio, 0);

		//todok NPC의 공격에 넉백속성이 있는 경우를 처리해줘야 한다
		/*
		// 공격 받아서 뒤로 밀림
		bool bPushSkip = false;

		float fKnockbackForce = pItem->GetKnockbackForce();
		if ( bPushSkip)
		{
			ZGetSoundEngine()->PlaySound( "fx_bullethit_mt_met");
			fKnockbackForce = 1.0f;
		}

		pVictim->OnKnockback( pAttacker->m_Direction, fKnockbackForce);
		*/

		// 이펙트 사운드 출력
		if (m_strSound.empty())
			ZGetSoundEngine()->PlaySoundBladeDamage(NULL, pos);	// 기본 쇳소리
		else
			ZGetSoundEngine()->PlaySound((char*)m_strSound.c_str(), pos);


		// 공격이 맞았다.
		bHit = true;
	}

	//todok 벽에 스파크 튀는 처리 해줘야 한다
/*
	// 캐릭터를 때리지 못했다면...
	// test 방향으로 벽과 충돌할경우 스파크..
	if ( !bHit)
	{

		rvector vPos = pAttacker->GetPosition();
		rvector vDir = AttackerNorDir;

		vPos.z += 130.f;

		RBSPPICKINFO bpi;

		if(pGame->GetWorld()->GetBsp()->Pick(vPos, vDir, &bpi)) {

			float fDist = Magnitude(vPos - bpi.PickPos);

			if (fDist < m_fRange) {

				rplane r = bpi.pInfo->plane;
				rvector vWallDir = rvector( r.a, r.b, r.c );
				Normalize(vWallDir);

				ZGetEffectManager()->AddSlashEffectWall( bpi.PickPos - (vDir*5.f) , vWallDir ,cm);

				rvector pos = bpi.PickPos;

				ZGetSoundEngine()->PlaySoundBladeConcrete(pItemDesc, pos);
			}
		}
	}
*/

	return;
}

void ZActorActionRangeShot::ProcessShot(const rvector& pos, const rvector& dir, ZObject* pOwner) const
{
	//rvector vMissilePos, vMissileDir;
	//GetMissilePosDir( vMissileDir, vMissilePos, targetPos);
	//ZGetGame()->m_WeaponManager.AddNewQuestProjectile(this, pos, dir, pOwner);

	ZGetGame()->m_WeaponManager.AddNewQuestProjectile(this, pos, dir, pOwner);
}
